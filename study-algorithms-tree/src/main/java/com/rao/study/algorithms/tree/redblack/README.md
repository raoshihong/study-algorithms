````
红黑树

avl树的性质决定了他的性能问题,因为avl树要求两颗子树相差高度最大为1，所以在插入删除操作时，会导致树的调整特别的频繁，而红黑树放弃了高度平衡，改为相对的平衡，要求

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长(原因就是红色节点不能连续两个出现,必须黑色隔开,黑色节点可以连续出现,所以可以整棵树都是黑色的,当整棵树都是黑色的时候,这棵树就是完全二叉树)。

最长的可能路径就是 红黑交叉，最短的可能路径就是全黑(红黑树在插入节点时,一般这个节点都是为红色)

        黑
       /  \
      红   黑
     / \
    黑  黑
   /
  黑
  

红黑树的平衡是通过两个操作来保证的,调整颜色和节点旋转
https://blog.csdn.net/yusimiao/article/details/97102312

## 红黑树的新增

`先新增,新增后节点后,再对整棵树进行自平衡`

红黑树的操作，插入操作跟普通的二叉树一致 ,插入完后,需要判断是否平衡(满足红黑树的几个限制条件),不平衡则需要通过调整颜色或者节点旋转来使树平衡

插入节点分以下情况几种情况(实际5种,因为左右对称)


1  1.如果当前插入的节点的父节点为空(即当前插入的节点为根节点),则直接将当前节点设置为黑色
   2.如果当前插入的节点的父节点不为空,则需要判断父节点的颜色
2      2.1 如果父节点为黑色,则直接插入的节点不用变更颜色
       2.2 如果父节点为红色,则需要叔叔节点来进行判断 (注:红黑树中的叶子节点为NIL节点,且颜色规定为黑色,判断叔叔节点之前需要先判断祖父节点是否存在,如果祖父节点不存在则直接返回父节点)
3          2.2.1 如果叔叔节点为红色(即叔叔节点不为空且颜色为红色),则将父节点和叔叔节点的颜色填充为黑色,当前插入节点的祖父节点的颜色填充为红色,将当前节点索引设置为祖父节点 （只有这块当前节点是会不断上升的,所以当前节点为root时退出循环）判断
           2.2.2 如果叔叔节点为黑色(注:这里的黑色包括叔叔节点存在且为黑色和叔叔节点不存在为nil,在红黑树中叶子节点为NIL节点,NIL节点为黑色),则需要判断当前节点的父节点的位置和当前插入节点的位置位置)
               2.2.2.1 如果当前插入的节点的父节点为其祖父节点的左节点
4                  2.2.2.1.1 如果当前插入的节点为其父节点的左节点,则需要进行LL型 ,右旋转,并交换当前插入节点的父节点和祖父节点的颜色,
5                  2.2.2.1.2 如果当前插入的节点为其父节点的右节点,则需要先对当前插入节点和父节点进行左旋,左旋后,再执行2.2.2.1.1的操作进行右旋
               2.2.2.2 如果当前插入的节点的父节点为其祖父节点的右节点
                   2.2.2.2.1 如果当前插入的节点为其父节点的右节点,则需要进行RR型 ,左旋转,并交换当前插入节点的父节点和祖父节点的颜色
                   2.2.2.2.2 如果当前插入的节点为其父节点的左节点,则需要先对当前插入节点和父节点进行右旋,右旋后,再执行2.2.2.2.1的操作进行左旋
                    



## 红黑树的删除

`红黑树的删除，跟普通二叉树删除一样，只是红黑树的删除节点后，需要进行自平衡，所以是先删除,删除节点后,对整棵树自底向上进行自平衡`


删除节点还是跟普通的二叉树一样，分以下三种情况

1.删除节点没有左右叶子节点,则直接删除
2.删除节点仅有一个子节点,则将子节点替代被删除的节点
3.删除节点有左右子节点,则需要采用(删除节点的右节点的最小子孙节点替代被删除的节点)或者(删除节点的左节点的最大子孙节点替代被删除的节点)

其实上面的删除节点可以理解为两种情况，第三种情况实际可以理解为对找到的最小子孙节点进行删除，而原来要删除的节点可以理解为只是内容的替换(可以查看AVL的删除节点的代码)

//下面以寻找左孩子节点的最大叶子节点为例
AVLNode leftMax = findLeftMax(root.getLeftChild());
root = remove(root,leftMax.getData());//对最小子孙节点进行删除
root.setData(leftMax.getData());//原节点对内容替换


在删除节点后，我们可以从被删除的节点和替代删除的节点来理解如何平衡
根据删除节点的情况，查找对应的替代节点
1.删除的节点没有左右子子节点，则替代节点可以理解为它自身（因为涉及到自平衡,所以需要将它自身理解为替代节点）
2.删除的节点只有一个子节点，则替代节点就为不为空的那个子节点
3.删除的节点有左右两个节点，这种情况，可以理解为实际是对该节点的最小子孙节点进行删除，所以替代节点可以理解为从它的最小子孙节点中查找，而删除的是最小子孙节点，那么又可以从1，2情况进行分析获取替代节点

        15黑
        /   \
       7红   35红
       / \   /  \
    3黑 10黑 30黑 45黑
    /   /          \
   2红 8红         50红

删除节点后，可能会影响整棵树对平衡，所以我们需要根据相关的删除情况进行相应的调整方式
1.如果删除的节点为红色，此时整棵树的黑色节点并没有改变，所以不用做平衡处理
2.如果删除的节点为黑色，此时因为整棵树的某个路径少了一个黑色节点可能导致失衡,所以需要进行平衡处理
    可以这么理解，如果此时删除的节点为父节点的左子节点，那么可以认为父节点的左子树少了一个黑色节点，右子树多了一个黑色节点，那么要想达到平衡，则需要将父节点的右子树的某个节点设置为红色，
    设置为红色节点的前提是：该节点的子节点必须都为黑色，父节点可以任意颜色（因为可以继续向上调整），所以可以这么理解，从替代节点的兄弟节点出发，如果兄弟节点的为黑色且兄弟节点的左右子节点都为黑色，
    那么我们可以大胆的将兄弟节点设置为红色节点，再将x节点设置为其父节点的索引，再次进行平衡判断（原因就是可能将其兄弟节点设置为红色节点后，其父节点也为红色，此时树失衡，所以将x再次设置为其父节点位子再次进行失衡判断）
    不断的往上平衡，直到根节点，因为根节点必须为黑色，所以平衡完后，最终肯定有一个节点变成了红色（可以理解为x的兄弟节点），所以整棵树达到平衡

从上面的分析，我们就相当于找到了平衡的突破口可以很好的处理平衡问题了，只要我们将节点不断平衡成x为黑色，兄弟节点为黑色，兄弟节点的左右子节点也为黑色，再根据上面的分析处理即可达到平衡
其他几种情况不断的转变，最终都转变成以上都突破口即可

平衡处理分以下几种情况：
    1.如果替代节点为红色，直接将替代节点设置为黑色，因为少了个黑色，所以直接补上黑色即可
    2.如果替代节点为黑色且不是树的根节点，则需要根据替代节点的兄弟节点进行判断
     2.1替代节点为其父节点的左节点的情况
        2.1.1 替代节点的兄弟节点为黑色
            2.1.1.1 兄弟节点的左右子节点都为黑色,此时设置兄弟节点颜色为红色，将替代节点的父节点位置赋值给替代节点，再对新对替换节点进行平衡处理（突破口）
            2.1.1.2 兄弟节点的右节点为红色，左节点颜色任意，则将兄弟节点设置为父节点的颜色，父节点的颜色设置为黑色，兄弟节点的右节点设置为黑色，再对父节点进行左选，最终形成wl为x对兄弟节点,而wl的颜色任意,所以相当于最终又开始对x进行新一轮对平衡处理
                          p          
                         / \        
                        x   w
                           / \
                          wl wr    
                       上面p颜色任意，x颜色为黑色,w颜色为黑色，wl的颜色任意，wr的颜色为红色
                       经过2.1.1.2的处理后
                            w
                           / \
                          p  wr
                         / \
                        x  wl
                        
                      此时x的兄弟节点变成了wl，因为wl的颜色任意,所以相当于右重新开始对x进行平衡判断
                      
            2.1.1.3 兄弟节点的右节点为黑色，左节点为红色，则兄弟节点设置为红色，兄弟的左节点设置为黑色，再对兄弟节点进行左旋，得到2.1.1.2的情况，再通过2.1.1.2重新对x节点进行平衡处理
                    
                
                             p          
                            / \        
                           x   w
                              / \
                             wl wr    
                          上面p颜色任意，x颜色为黑色,w颜色为黑色，wl的颜色为红色，wr的颜色为黑色
                          经过2.1.1.2的处理后
                               p
                              / \
                             x  wl
                                  \
                                   w
                                    \
                                    wr
                             此时x的兄弟节点变成了wl，此时wl的颜色为黑色，w的颜色变成了红色，刚好满足2.1.1.2的情况，所以再根据2.1.1.2的情况进行处理
                             
                         
        2.1.2 替代节点的兄弟节点为红色，则将父节点设置为红色，兄弟节点设置为黑色，对父节点进行左旋，得到x对兄弟节点为黑色，那么又相当于再次对x为黑色，x的兄弟节点为黑色对情况进行判断兄弟的左右子节点的颜色判断
              红黑树如果一个节点为黑色，那么它的父节点一定为黑色，它的左右子节点一定为黑色，所以经过2.1.2的情况处理，最终x的兄弟节点变成了黑色，所以又要重新对x进行上面对情况对处理
              
              
     
     2.2 替代节点为父节点对右节点的情况
        这种情况跟上面的左节点逻辑是一样的，只是左右节点互换
        
        
````       
    

              
  











































